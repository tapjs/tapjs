{"version":3,"file":"tap.js","sourceRoot":"","sources":["../../src/tap.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * The root TAP object singleton, the `t` you get when you\n * `import t from 'tap'`\n *\n * Inherits from {@link @tapjs/test!index.Test}, with all plugins applied, and\n * has additional functionality to automatically pipe to standard output, set\n * the process exit code appropriately, and infer options from environment\n * variables.\n *\n * @module\n *\n * @see {@link @tapjs/core!tap.TAP}\n */\nimport { Test, TestOpts } from '@tapjs/test'\nimport { Domain } from 'async-hook-domain'\nimport { Minipass, PipeOptions } from 'minipass'\nimport { isMainThread, parentPort } from 'node:worker_threads'\nimport { Handler, onExit } from 'signal-exit'\nimport { FinalResults } from 'tap-parser'\nimport { diags } from './diags.js'\nimport { IMPLICIT } from './implicit-end-sigil.js'\nimport { Extra, MILLISECONDS } from './index.js'\nimport { env, proc } from './proc.js'\nimport { TestBase } from './test-base.js'\n\nconst stdout = proc?.stdout\n\nconst privSym = Symbol.for('TAP private constructor')\ntype PrivateTAPCtor = {\n  [privSym]: true\n}\nconst privateTAPCtor: PrivateTAPCtor = {\n  [privSym]: true,\n}\n\nlet instance: TAP | undefined = undefined\n\nconst envFlag = (key: string) =>\n  env[key] === undefined ? undefined : env[key] === '1'\n\nlet piped = false\nlet registered = false\nlet autoend = false\n\n/**\n * This is a singleton subclass of the {@link @tapjs/test!index.Test} base\n * class.\n *\n * Instantiate it by calling the exported {@link @tapjs/core!tap.tap} method.\n *\n * It has all of the same plugins, fields, properties etc of a \"normal\"\n * Test object, but with some additional characteristics to make it\n * suitable for use as the root test runner.\n *\n * - The {@link @tapjs/core!tap.TAP#register} method will hook onto the process\n *   object, to set the exit code to 1 if there are test failures, and ignore\n *   any `EPIPE` errors that happen on stdout.  (This is quite common in cases\n *   where a test aborts, and then attempts to write more data.)\n *\n * - A brief summary is printed at the end of the test run.\n *\n * - If piped to stdout, then `this.register()` will be called automatically.\n *\n * - If not piped anywhere else, the first time it writes any data, it will\n *   begin piping to stdout.\n *\n * - Options are set based on relevant environment variables, rather than\n *   taking an options object, since in normal cases, it will be instantiated\n *   automatically before any user code is run.\n *\n * - The test will automatically implicitly end when the process exits.  If\n *   there are any unfinished tests at this time, they will be emitted as\n *   failures.\n *\n * - If a `teardown` function is added, then the test will automatically\n *   implicitly end if it is idle for 3 consecutive `setTimeout` deferrals.\n *   This is a bit of a kludge, but it allows tests to run servers or other\n *   things that would prevent a graceful process exit, and close them down\n *   in a teardown function.\n *\n * - Lastly, since test files are often spawned by the runner using\n *   `t.spawn()`, this class listens for the timeout signal, and attempts to\n *   print diagnostic information about currently active handles and requests,\n *   as these are usually the cause of a test hanging indefinitely.\n */\nclass TAP extends Test {\n  /**\n   * @internal\n   */\n  constructor(priv: PrivateTAPCtor, opts: TestOpts = {}) {\n    /* c8 ignore start */\n    if (priv !== privateTAPCtor) {\n      throw new Error(\n        'the TAP singleton should not be instantiated directly'\n      )\n    }\n    const timeoutEnv = env.TAP_TIMEOUT || '30'\n    /* c8 ignore stop */\n\n    const timeout = Number(timeoutEnv) * 1000\n    const options = {\n      name: 'TAP',\n      diagnostic: envFlag('TAP_DIAG'),\n      bail: envFlag('TAP_BAIL'),\n      debug:\n        envFlag('TAP_DEBUG') ||\n        /\\btap\\b/i.test(env['NODE_DEBUG'] || ''),\n      omitVersion: envFlag('TAP_OMIT_VERSION'),\n      preserveWhitespace: !envFlag('TAP_OMIT_WHITESPACE'),\n      timeout,\n      failTodo: envFlag('TAP_FAIL_TODO'),\n      failSkip: envFlag('TAP_FAIL_SKIP'),\n      passes: envFlag('TAP_PASSES'),\n      // these are always set in our tests.\n      /* c8 ignore start */\n      childId: Number(env.TAP_CHILD_ID) || 0,\n      jobId: Number(env.TAP_JOB_ID) || 0,\n      /* c8 ignore stop */\n      ...opts,\n    }\n\n    // plugins get applied right here:\n    super(options)\n\n    instance = g[privSym] = this\n    this.on('idle', () => maybeAutoend())\n    this.on('complete', (results: FinalResults) =>\n      this.#oncomplete(results)\n    )\n\n    // only attach the teardown autoend if we're using the teardown plugin\n    // we test in this convoluted manner rather than this.pluginLoaded\n    // because otherwise we have a cyclical dep link between `@tapjs/core`\n    // and `@tapjs/after` which prevents TS from being able to build properly\n    // from a cold start.\n    const td = this as typeof this & {\n      teardown?: (fn: () => any) => void\n    }\n    const { teardown } = td\n    if (typeof teardown === 'function') {\n      type TD = typeof teardown\n      td.teardown = (...args: Parameters<TD>): ReturnType<TD> => {\n        autoend = true\n        td.teardown = teardown\n        return td.teardown(...args)\n      }\n    }\n\n    this.runMain(() => {})\n  }\n\n  get registered() {\n    return registered\n  }\n\n  /**\n   * register this tap instance as being in charge of the current process\n   * ignore epipe errors, set exit code, etc.\n   *\n   * Happens automatically if piped to stdout.\n   */\n  register() {\n    if (registered) return\n    registered = true\n    registerTimeoutListener(this)\n    ignoreEPIPE()\n    proc?.once('beforeExit', () => {\n      ;(this as unknown as TestBase).end(IMPLICIT)\n    })\n    proc?.once('exit', () => {\n      if (!this.results) {\n        this.endAll()\n      }\n    })\n    // create a root domain to handle throws that happen outside\n    // of any subtest.\n    const rootDomain = new Domain((er, type) =>\n      this.hookDomain.onerror(er, type)\n    )\n    this.hook.onDestroy = () => rootDomain.destroy()\n  }\n\n  onbail(reason?: string) {\n    if (registered) {\n      this.debug('bailout, exit 1')\n      super.write(`Bail out!${reason ? ' ' + reason : ''}\\n`)\n    }\n    super.onbail(reason)\n    // don't fast-exit in the runner, so we can print the reason for\n    // the bailout on test failure.\n    if (registered && this.context !== Symbol.for('tap.isRunner')) {\n      proc?.exit(1)\n    }\n  }\n\n  /**\n   * Just the normal Minipass.pipe method, but automatically registers\n   * if the destination is stdout.\n   */\n  pipe<W extends Minipass.Writable>(dest: W, opts?: PipeOptions): W {\n    piped = true\n    if (stdout && dest === stdout) {\n      this.register()\n    }\n    return super.pipe(dest, opts)\n  }\n\n  /**\n   * Just the normal Minipass.write method, but automatically pipes\n   * to stdout if not piped anywhere else.\n   */\n  write(chunk: string): boolean {\n    if (!registered && !piped && stdout) {\n      this.pipe(stdout)\n    }\n    return super.write(chunk)\n  }\n\n  #oncomplete(results: FinalResults) {\n    // only print this added info in the root test, otherwise\n    // it's a bit extraneous.\n    if (!env.TAP_CHILD_ID) {\n      this.comment(this.counts.toJSON())\n      this.comment(`time=${this.time}ms`)\n    }\n\n    if (registered && proc && !results.ok) {\n      this.debug('TAP results not ok, setting exitCode', results)\n      proc.exitCode = 1\n    }\n  }\n\n  /**\n   * Similar to the normal {@link @tapjs/core!test-base.TestBase#timeout}, but\n   * with the added feature that it will kill the process with `SIGALRM` if it\n   * has been registered, and will decorate the diagnostics with some\n   * information about currently running handles and requests, as these may be\n   * the reason the process is not gracefully closing in time.\n   *\n   * The root test runner will time out if the process receives a `SIGALRM`\n   * signal, or if it receives a timeout message via IPC or worker thread\n   * channel.\n   */\n  timeout(\n    options: {\n      expired?: string\n      signal?: NodeJS.Signals | null\n    } = { expired: this.name, signal: null }\n  ) {\n    const occ = this.occupied\n    const extra = Object.assign(\n      getTimeoutExtra(options.signal),\n      options\n    )\n    super.timeout(extra)\n    if (occ) this.emit('timeout', extra)\n    // don't stick around\n    // this is just a defense if the SIGALRM signal is caught, since\n    // we'll exit forcibly anyway.\n    /* c8 ignore start */\n    if (registered) {\n      setTimeout(() => {\n        didProcessTimeout = true\n        alarmKill()\n      }, 10000)?.unref?.()\n    }\n    /* c8 ignore stop */\n  }\n\n  // tell our parent process about our intended timeout\n  setTimeout(n: MILLISECONDS) {\n    const msg = {\n      setTimeout: n,\n      key: env.TAP_CHILD_KEY,\n      child: env.TAP_CHILD_ID,\n    }\n    proc?.send?.(msg)\n    // workers can't generate coverage\n    /* c8 ignore start */\n    parentPort?.postMessage(msg)\n    /* c8 ignore stop */\n    return super.setTimeout(n)\n  }\n}\n\nconst shouldAutoend = (instance: TAP | undefined): instance is TAP =>\n  !!autoend && !!instance?.idle\n\nlet autoendTimer: NodeJS.Timeout | undefined = undefined\nconst maybeAutoend = () => {\n  clearTimeout(autoendTimer)\n  if (!shouldAutoend(instance)) return\n  autoendTimer = setTimeout(() => {\n    clearTimeout(autoendTimer)\n    if (shouldAutoend(instance)) {\n      autoendTimer = setTimeout(() => {\n        clearTimeout(autoendTimer)\n        if (shouldAutoend(instance)) {\n          ;(instance as unknown as TestBase).end(IMPLICIT)\n          autoend = false\n        }\n      })\n    }\n  })\n}\n\n// SIGALRM means being forcibly killed due to timeout\nconst registerTimeoutListener = (t: TAP) => {\n  const oe: Handler = (_, sig) => {\n    if (sig === 'SIGALRM' && !didProcessTimeout) {\n      onProcessTimeout(t, sig)\n      onExit(oe)\n      return true\n    }\n  }\n  onExit(oe)\n  const onMessage = (\n    msg:\n      | {\n          tapAbort?: string\n          key?: string\n          child?: string\n        }\n      | any\n  ) => {\n    if (\n      msg &&\n      typeof msg === 'object' &&\n      msg.tapAbort === 'timeout' &&\n      msg.key === env.TAP_CHILD_KEY &&\n      msg.child === env.TAP_CHILD_ID\n    ) {\n      onProcessTimeout(t, 'SIGALRM')\n    }\n  }\n\n  // this is a bit of a handshake agreement between the root TAP object\n  // and the Spawn and Worker classes. Because Windows cannot catch and\n  // process posix signals, we have to use an IPC message to send the\n  // timeout signal.\n  // t.spawn() will always open an ipc channel on fd 3 for this purpose,\n  // and t.worker() will use the worker message port.\n  // The key and childId are just a basic gut check to ensure that we don't\n  // treat a message as a timeout unintentionally, though of course that\n  // would be extremely rare.\n\n  /* c8 ignore start */\n  proc?.on('message', onMessage)\n  parentPort?.on('message', onMessage)\n\n  // We don't want the channel to keep the child running\n  //@ts-ignore\n  proc?.channel?.unref()\n  parentPort?.unref()\n  /* c8 ignore stop */\n}\n\nconst getTimeoutExtra = (signal: NodeJS.Signals | null = null) => {\n  const p = process as unknown as {\n    _getActiveHandles: () => any[]\n    _getActiveRequests: () => any[]\n  }\n\n  /* c8 ignore start */\n  const handles = (p._getActiveHandles() || []).filter(\n    /* c8 ignore stop */\n    h => h !== proc?.stdout && h !== proc?.stdin && h !== proc?.stderr\n  )\n  const requests = p._getActiveRequests()\n\n  const extra: Extra = {\n    at: undefined,\n    signal,\n  }\n\n  // node 20 doesn't have requests in the same way as node 18\n  // we get different objects, handles vs requests, etc.\n  // it's all very \"internal machinery\", version specific and unstable\n  // there are tests to show that we can get SOMETHING in expected cases,\n  // but it'll be completely differerent across node versions.\n  /* c8 ignore start */\n  if (requests.length) {\n    extra.requests = requests.map(r => {\n      if (!r || typeof r !== 'object') return r\n      const ret: {\n        type: string\n        context?: any\n      } = {\n        type: r.constructor.name,\n      }\n      if (r.context) ret.context = r.context\n      return ret\n    })\n  }\n\n  if (handles.length) {\n    extra.handles = handles.map(h => {\n      if (!h || typeof h !== 'object') return h\n      const ret: {\n        type: string\n        msecs?: number\n        events?: string[]\n        sockname?: string\n        connectionKey?: string\n      } = {\n        type: h.constructor.name,\n      }\n      if (h.msecs) ret.msecs = h.msecs\n      if (h._events) ret.events = Object.keys(h._events)\n      if (h._sockname) ret.sockname = h._sockname\n      if (h._connectionKey) ret.connectionKey = h._connectionKey\n      return ret\n    })\n  }\n  /* c8 ignore stop */\n\n  return extra\n}\n\nlet didProcessTimeout = false\nconst onProcessTimeout = (\n  t: TAP,\n  signal: NodeJS.Signals | null = null\n) => {\n  // pretty much impossible to do this, since we forcibly exit,\n  // but it is theoretically possible if SIGALRM is caught.\n  /* c8 ignore start */\n  if (didProcessTimeout) return\n  /* c8 ignore stop */\n  didProcessTimeout = true\n\n  const extra = getTimeoutExtra(signal)\n\n  // ignore coverage here because it happens after everything\n  // must have been shut down.\n  /* c8 ignore start */\n  if (!t.results) {\n    t.timeout(extra)\n  } else {\n    if (extra.handles || extra.requests) {\n      delete extra.signal\n      if (!extra.at) {\n        delete extra.at\n      }\n    }\n    console.error(diags(extra))\n  }\n  // defer to print the timeout failure before termination\n  setTimeout(() => alarmKill())\n}\n\nconst alarmKill = () => {\n  // can only kill in main thread, worker threads will be terminated\n  if (!isMainThread) return\n\n  // SIGALRM isn't supported everywhere,\n  // and we won't be able to catch it on windows anyway.\n  /* c8 ignore start */\n  try {\n    proc?.kill(proc?.pid, 'SIGALRM')\n  } catch {\n    proc?.kill(proc?.pid, 'SIGKILL')\n  }\n  const t = setTimeout(() => {\n    proc?.kill(proc?.pid, 'SIGKILL')\n  }, 500)\n  if (t.unref) t.unref()\n}\n/* c8 ignore stop */\n\nconst ignoreEPIPE = () => {\n  /* c8 ignore start */\n  if (!stdout?.emit) return\n  /* c8 ignore stop */\n  const emit = stdout.emit\n  stdout.emit = (ev: string, ...args: any[]) => {\n    const er = args[0] as NodeJS.ErrnoException\n    if (ev === 'error' && er?.code === 'EPIPE') {\n      return false\n    }\n    //@ts-ignore\n    return emit.call(stdout, ev, ...args)\n  }\n}\n\nconst g = globalThis as typeof globalThis & {\n  [privSym]: TAP\n}\n\n/**\n * The exported function instantiates a {@link @tapjs/core!tap.TAP} object if\n * we don't already have one, or return the one that was previously\n * instantiated.\n *\n * Options may be provided, which will override the environment settings,\n * but they are ignored if the instance was already created.\n */\nexport const tap = (opts?: TestOpts) =>\n  instance ?? g[privSym] ?? new TAP(privateTAPCtor, opts)\n\nexport type { TAP }\n"]}