{"version":3,"file":"test-base.js","sourceRoot":"","sources":["../../src/test-base.ts"],"names":[],"mappings":"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","sourcesContent":["import * as stack from '@tapjs/stack'\nimport type { Test } from '@tapjs/test'\nimport { isPromise } from 'is-actual-promise'\nimport { Minipass } from 'minipass'\nimport assert from 'node:assert'\nimport { relative } from 'node:path'\nimport { hrtime } from 'node:process'\nimport { Readable } from 'node:stream'\nimport { format } from 'node:util'\nimport { FinalResults, Result as ParserResult } from 'tap-parser'\nimport { Deferred } from 'trivial-deferred'\nimport { Base, BaseOpts } from './base.js'\nimport { esc } from './esc.js'\nimport { extraFromError } from './extra-from-error.js'\nimport { mainScript } from './main-script.js'\nimport { argv, cwd } from './proc.js'\nimport { Spawn } from './spawn.js'\nimport { Stdin } from './stdin.js'\nimport { Result, TestPoint } from './test-point.js'\nimport { Waiter } from './waiter.js'\nimport { Worker } from './worker.js'\n\nimport { IMPLICIT } from './implicit-end-sigil.js'\nimport {\n  Extra,\n  MessageExtra,\n  TapBaseEvents,\n  TapFile,\n} from './index.js'\nimport { normalizeMessageExtra } from './normalize-message-extra.js'\n\nconst VERSION = 'TAP version 14\\n'\n\n/**\n * Options that can be passed to TestBase objects\n */\nexport interface TestBaseOpts extends BaseOpts {\n  /**\n   * The number of jobs to run in parallel. Defaults to 1\n   */\n  jobs?: number\n\n  /**\n   * Test function called when this Test is executed\n   * This is usually not set on the extra object, but as an argument to\n   * the `t.test(..)` method, just defined here so TS doesn't complain\n   * when we reference it in the various flow control machinery.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  cb?: (...args: any[]) => any\n}\n\nconst queueEmpty = <T extends TestBase>(t: T) =>\n  t.queue.length === 0 ||\n  (t.queue.length === 1 && t.queue[0] === VERSION)\n\n/**\n * Sigil to put in the queue to signal the end of all things\n */\nconst EOF = Symbol('EOF')\n\nexport type { EOF }\n\n/**\n * Entries in the {@link @tapjs/core!test-base.TestBase#queue} awaiting\n * processing\n */\nexport type QueueEntry =\n  | string\n  | TestPoint\n  | Base\n  | typeof EOF\n  | Waiter\n  | [method: string, ...args: any[]]\n  | (() => any)\n\n/**\n * the promise returned by t.test(), t.spawn(), etc.\n * If a subtest was not created (because of being marked skipped,\n * the parent having bailed out, etc.) then the `subtest` field\n * will be set to `null`.\n */\nexport interface PromiseWithSubtest<S extends Base>\n  extends Promise<FinalResults | null> {\n  subtest: S | null\n}\n\n/**\n * Events emitted by TestBase and inherited classes\n */\nexport interface TestBaseEvents extends TapBaseEvents {\n  /**\n   * Emitted when a subtest begins running\n   *\n   * @event\n   */\n  subtestStart: [p: Base]\n  /**\n   * Emitted when a subtest is completed and no longer active, but may\n   * not yet have been processed by the parent test.\n   *\n   * @event\n   */\n  subtestEnd: [p: Base]\n  /**\n   * Emitted when a subtest begins to be processed.\n   *\n   * @event\n   */\n  subtestProcess: [p: Base]\n  /**\n   * Emitted when a subtest is added to its parent's management\n   *\n   * @event\n   */\n  subtestAdd: [p: Base]\n  /**\n   * Emitted whenever the test has an assertion result, with the minimal\n   * `{ ok, message, extra }` result object.\n   *\n   * @event\n   */\n  result: [res: Result]\n  /**\n   * Emitted when the parser emits a result, with the full parser result\n   * object\n   *\n   * @event\n   */\n  assert: [res: ParserResult]\n  /**\n   * Emitted when a child test is initiated that will process stdin\n   * as a TAP stream\n   *\n   * @event\n   */\n  stdin: [s: Stdin]\n  /**\n   * Emitted when a child test is initiated that will process a subprocess\n   * output as a TAP stream\n   *\n   * @event\n   */\n  spawn: [s: Spawn]\n  /**\n   * Emitted when a child test is initiated that will process a node\n   * Worker thread's output as a TAP stream\n   *\n   * @event\n   */\n  worker: [w: Worker]\n  /**\n   * Emitted when a child tests is initiated that replays a .tap file.\n   *\n   * @event\n   */\n  tapFile: [tf: TapFile]\n  /**\n   * Emitted when the test is in an idle state, not waiting\n   * for anything, with nothing in its queue. Used by the root\n   * {@link @tapjs/core!tap.TAP} singleton to know when to automatically\n   * terminate.\n   *\n   * @event\n   */\n  idle: []\n}\n\n/**\n * The TestBase class is the parent class of {@link @tapjs/test!index.Test},\n * and passed\n * to all plugins at instantiation time.\n *\n * This implements subtest functionality, TAP stream generation,\n * lifecycle events, and only the basic pass/fail assertion methods.\n *\n * All other features are added with plugins.\n */\nexport class TestBase extends Base<TestBaseEvents> {\n  // NB: generated pluginified Test class needs to declare over this\n  declare parent?: TestBase\n  declare options: TestBaseOpts\n\n  /**\n   * Attached when the Test class is instantiated from a TestBase,\n   * as a reference to the final plugged-in Test instance.\n   * If TestBase is used directly (outside the context of a plugin)\n   * or during plugin setup time, this will be undefined, so watch out.\n   *\n   * @group Test Reflection\n   */\n  t!: Test\n\n  /**\n   * A promise that resolves when the test is done.\n   *\n   * @group Internal Machinery\n   */\n  donePromise?: Promise<any> & {\n    tapAbortPromise?: () => void\n  }\n\n  /**\n   * The number of subtests to run in parallel, if allowed\n   *\n   * @group Test Lifecycle Management\n   */\n  jobs: number\n\n  /**\n   * Array of all subtests that have been added/scheduled,\n   * and have not yet completed.\n   *\n   * @group Internal Machinery\n   */\n  subtests: Base[] = []\n  /**\n   * The pool of parallel tests currently in process\n   *\n   * @group Internal Machinery\n   */\n  pool: Set<Base> = new Set()\n  /**\n   * Queue of items awaiting processing. Can be any\n   * {@link @tapjs/core!test-base.QueueEntry} item.\n   *\n   * @group Internal Machinery\n   */\n  queue: QueueEntry[] = [VERSION]\n  /**\n   * Function that will get this test as an argument when it is processed\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  cb?: (...args: any[]) => any\n\n  /**\n   * The count of all assertions made directly on this test.\n   *\n   * @group Test Reflection\n   */\n  count: number = 0\n\n  /**\n   * Set true when {@link @tapjs/core!test-base.TestBase#end} is called\n   */\n  ended: boolean = false\n\n  /**\n   * Show diagnostics for this test. A value of `null` means that\n   * diagnostics will be shown only if the test is failing.\n   */\n  diagnostic: null | boolean = null\n\n  #planEnd: number = -1\n  #planAt?: stack.CallSiteLike\n  #printedResult: boolean = false\n  #endingAll: boolean = false\n  #endingAllSub: boolean = false\n  #explicitEnded: boolean = false\n  #explicitPlan: boolean = false\n  #promiseEnded: boolean = false\n  #multiEndThrew: boolean = false\n  #n: number = 0\n  #noparallel: boolean = false\n  #occupied: null | Waiter | Base = null\n  // set to true if the end should be explicit\n  #awaitingEnd: typeof IMPLICIT | boolean = false\n  #pushedBeforeEnd: boolean = false\n  #nextChildId: number = 1\n  #currentAssert?: Function | ((..._: any) => any)\n  #processing: boolean = false\n  #doingStdinOnly: boolean = false\n  #calledOnEOF: boolean = false\n  #jobIds: Set<number>\n\n  /**\n   * Subtests that are currently in process.\n   *\n   * @group Internal Machinery\n   */\n  activeSubtests: Set<Base> = new Set()\n\n  /**\n   * Count of all asserts in this and all child tests,\n   * excluding child test summary points\n   *\n   * @group Test Reflection\n   */\n  get assertTotals() {\n    return this.counts\n  }\n\n  /**\n   * true if the test has printed at least one TestPoint\n   *\n   * @group Test Reflection\n   */\n  get printedResult(): boolean {\n    return this.#printedResult\n  }\n\n  /**\n   * true if the test is currently waiting for something to finish\n   *\n   * @group Test Reflection\n   */\n  get occupied(): boolean {\n    return !!this.#occupied\n  }\n\n  constructor(options: TestBaseOpts) {\n    super(options)\n\n    this.parser.on('result', r => {\n      this.emit('assert', r)\n    })\n\n    this.jobs = (options.jobs && Math.max(options.jobs, 1)) || 1\n\n    if (typeof options.diagnostic === 'boolean') {\n      this.diagnostic = options.diagnostic\n    }\n\n    if (options.cb) {\n      this.#setCB(options.cb)\n    }\n    this.#jobIds = new Set()\n  }\n\n  #setCB<T extends TestBase>(this: T, cb: (t: T) => any) {\n    this.cb = (...args: any[]) =>\n      this.hook.runInAsyncScope(cb, this.t || this, ...args)\n  }\n\n  /**\n   * immediately exit this and all parent tests with a TAP\n   * Bail out! message.\n   *\n   * @group Test Lifecycle Management\n   */\n  bailout(message?: string) {\n    if (this.parent && (this.results || this.ended)) {\n      this.parent.bailout(message)\n    } else {\n      this.#process()\n      message = message ? ' ' + ('' + esc(message)).trim() : ''\n      message = message.replace(/[\\r\\n]/g, ' ')\n      this.parser.write('Bail out!' + message + '\\n')\n    }\n    this.#end(IMPLICIT)\n    this.#process()\n  }\n\n  /**\n   * output a TAP comment, formatted like console.log()\n   *\n   * If the test is currently awaiting a child test, it will be deferred\n   * until after the child test completes.\n   *\n   * If the test is already completed, the comment will be emitted\n   * on the parent, or if no parent is available, it will be printed\n   * to standard output.\n   */\n  comment(...args: any[]) {\n    const body = format(...args)\n    const message =\n      ('# ' + body.split(/\\r?\\n/).join('\\n# ')).trim() + '\\n'\n\n    if (this.results || this.ended || this.#awaitingEnd) {\n      // the fallback to console.log is a bit weird,\n      // but the only alternative seems to be to just lose it.\n      if (this.streamWritable) {\n        super.write(message)\n        this.parser.emit('comment', message.trim())\n      } else if (this.parent) {\n        this.parent.comment(...args)\n      } else {\n        console.log(message.trimEnd())\n      }\n    } else if (this.#occupied) {\n      this.queue.push(message)\n      this.#process()\n    } else {\n      this.parser.write(message)\n    }\n  }\n\n  /**\n   * Called when the test times out.\n   * Options are passed as diagnostics to the threw() method\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  timeout(\n    options: Extra & { expired?: string } = { expired: this.name },\n  ) {\n    options.expired = options.expired || this.name\n    if (this.#occupied && this.#occupied instanceof Base) {\n      this.#occupied.timeout(options)\n    } else {\n      super.timeout(options)\n    }\n    this.#end(IMPLICIT)\n  }\n\n  /**\n   * Set TAP pragma configs to affect the behavior of the parser.\n   * Only `strict` is supported by the parser.\n   */\n  pragma(set: { [k: string]: boolean }) {\n    const p = Object.keys(set).reduce(\n      (acc, i) => acc + 'pragma ' + (set[i] ? '+' : '-') + i + '\\n',\n      '',\n    )\n    this.queue.push(p)\n    this.#process()\n  }\n\n  /**\n   * Specify the number of Test Points expected by this test.\n   * Outputs a TAP plan line.\n   *\n   * @group Test Lifecycle Management\n   */\n  plan(n: number, comment?: string): void\n  plan(n: number, comment: string, implicit: typeof IMPLICIT): void\n  plan(n: number, comment?: string, implicit?: typeof IMPLICIT) {\n    if (this.bailedOut) {\n      return\n    }\n\n    if (this.#explicitPlan) {\n      throw new Error('Cannot set plan more than once')\n    }\n    this.#explicitPlan = implicit !== IMPLICIT\n    if (this.#explicitPlan) {\n      this.#planAt = stack.at(this.plan)\n    }\n\n    if (this.#planEnd !== -1) {\n      throw new Error('Cannot set plan after test has ended')\n    }\n\n    if (typeof n !== 'number' || n < 0 || n !== Math.floor(n)) {\n      throw new TypeError('plan must be a non-negative integer')\n    }\n\n    // Cannot get any tests after a trailing plan, or a plan of 0\n    const ending = this.count !== 0 || n === 0\n\n    if (n === 0 && comment && !this.options.skip) {\n      this.options.skip = comment\n    }\n\n    this.#planEnd = n\n    comment = comment ? ' # ' + esc(comment.trim()) : ''\n    this.queue.push('1..' + n + comment + '\\n')\n\n    if (ending) {\n      this.#end(IMPLICIT)\n    } else {\n      this.#process()\n    }\n  }\n\n  /**\n   * A passing (ok) Test Point.\n   *\n   * @group Assertion Methods\n   */\n  pass(...[msg, extra]: MessageExtra) {\n    this.currentAssert = this.pass\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('(unnamed test)', args)\n    this.#printResult(true, ...me)\n    return true\n  }\n\n  /**\n   * A failing (not ok) Test Point\n   *\n   * @group Assertion Methods\n   */\n  fail(...[msg, extra]: MessageExtra) {\n    this.currentAssert = this.fail\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('(unnamed test)', args)\n    this.#printResult(false, ...me)\n    return !!(me[1].todo || me[1].skip)\n  }\n\n  /**\n   * The current assertion being processed. Set at the start of all\n   * assertions, and used for calculating stack traces.\n   *\n   * @group Internal Machinery\n   */\n  get currentAssert() {\n    return this.#currentAssert\n  }\n  set currentAssert(\n    fn: undefined | Function | ((...a: any[]) => any),\n  ) {\n    if (!this.#currentAssert && typeof fn === 'function') {\n      this.#currentAssert = fn\n    }\n  }\n\n  // apply flags from our options onto an Extra or TestOpts object\n  #inheritFlags(extra: Extra) {\n    const inheritedFlags = [\n      'bail',\n      'debug',\n      'passes',\n      'failTodo',\n      'failSkip',\n      'failOnly',\n      'diagnostic',\n    ] as const\n    for (const k of inheritedFlags) {\n      if (\n        extra[k] === undefined &&\n        typeof this.options[k] === 'boolean'\n      ) {\n        extra[k] = this.options[k]\n      }\n    }\n  }\n\n  /**\n   * Print a Test Point.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  #printResult(\n    ok: boolean,\n    message: string,\n    extra: Extra,\n    front: boolean = false,\n  ) {\n    this.currentAssert = this.#printResult\n    this.#printedResult = true\n\n    const n = this.count + 1\n    const fn = this.currentAssert\n    this.#currentAssert = undefined\n\n    if (this.#planEnd !== -1 && n > this.#planEnd) {\n      // prevent infinite regress of \"plan exceeded\" fails\n      if (!this.passing()) return\n\n      // the 'automatic end' can only occur with the root TAP object\n      // and even then, pretty hard to trigger, since it would mean\n      // going several turns of the event loop and hitting it at just\n      // the right time before the process quits.\n      const failMessage =\n        this.#promiseEnded ? 'test assertion after Promise resolution'\n        : this.#explicitEnded ?\n          'test assertion after end() was called'\n        : this.#explicitPlan ? 'test assertion count exceeds plan'\n        : /* c8 ignore start */ 'assertion after automatic end'\n      /* c8 ignore stop */\n\n      const er = new Error(failMessage, {\n        cause: {\n          test: this.name,\n          plan: this.#planEnd,\n        },\n      })\n      Error.captureStackTrace(er, fn)\n      this.threw(er, extraFromError(er))\n      return\n    }\n\n    if (extra.skip && this.options.failSkip) {\n      extra.failedSkip = extra.skip\n      delete extra.skip\n      ok = false\n    }\n\n    if (extra.todo && this.options.failTodo) {\n      extra.failedTodo = extra.todo\n      delete extra.todo\n      ok = false\n    }\n\n    if (extra.only && this.options.failOnly) {\n      extra.failedOnly = 'only:true tests not allowed'\n      delete extra.only\n      ok = false\n    }\n\n    const diagnostic =\n      typeof extra.diagnostic === 'boolean' ? extra.diagnostic\n      : typeof this.diagnostic === 'boolean' ? this.diagnostic\n      : extra.skip || extra.todo ? false\n      : !ok\n\n    if (diagnostic) {\n      extra.diagnostic = true\n    }\n\n    if (extra.at === null) {\n      delete extra.at\n      delete extra.stack\n    } else if (\n      typeof extra.stack === 'string' &&\n      extra.stack &&\n      !extra.at\n    ) {\n      const parsed = stack.parseStack(extra.stack)\n      extra.at = parsed[0]\n      extra.stack = parsed.map(c => String(c) + '\\n').join('')\n    } else if (!extra.at && typeof fn === 'function') {\n      const showStack = !ok && !extra.skip && !extra.todo\n      const showAt = showStack || extra.diagnostic === true\n      if (showAt) {\n        const st = stack.capture(80, fn)\n        extra.at = st[0]\n        if (showStack) {\n          extra.stack = st.map(c => String(c)).join('\\n')\n        }\n      }\n    }\n\n    this.count = n\n    message = message + ''\n    const res: Result = { ok, message, extra }\n\n    this.#inheritFlags(extra)\n    const tp = new TestPoint(ok, message, extra)\n\n    // when we jump the queue, skip an extra line\n    if (front) {\n      tp.message = tp.message.trimEnd() + '\\n\\n'\n    }\n\n    // push to the front when we are occupied by a waiter and have ended,\n    // otherwise the relevant awaited assertion will be lost.\n    if (\n      this.#occupied &&\n      this.#occupied instanceof Waiter &&\n      this.#awaitingEnd\n    ) {\n      front = true\n    }\n\n    if (front) {\n      if (extra.tapChildBuffer || extra.tapChildBuffer === '') {\n        this.#writeSubComment(tp)\n        this.parser.write(extra.tapChildBuffer)\n      }\n      this.emit('result', res)\n      this.parser.write(tp.ok + ++this.#n + tp.message)\n      if (this.bail && !ok && !extra.skip && !extra.todo) {\n        this.parser.write('Bail out! ' + message + '\\n')\n      }\n    } else {\n      this.queue.push(tp)\n      if (this.bail && !ok && !extra.skip && !extra.todo) {\n        this.queue.push('Bail out! ' + message + '\\n')\n      }\n    }\n\n    this.#process()\n    if (this.#planEnd === this.count) {\n      if (!this.#awaitingEnd && !this.#occupied) this.#end(IMPLICIT)\n      else this.#awaitingEnd ||= IMPLICIT\n    }\n    this.#process()\n  }\n\n  /**\n   * Explicitly mark the test as completed, outputting the TAP plan line if\n   * needed.\n   *\n   * This is not required to be called if the test function returns a promise,\n   * or if a plan is explicitly declared and eventually fulfilled.\n   *\n   * @group Test Lifecycle Management\n   */\n  end(implicit?: typeof IMPLICIT): this {\n    this.#end(implicit)\n    return this\n  }\n\n  /**\n   * The leading `# Subtest` comment that introduces a child test\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  #writeSubComment<T extends TestPoint | Base>(p: T) {\n    // name will generally always be set\n    /* c8 ignore start */\n    const stn = p.name ? ': ' + esc(p.name) : ''\n    /* c8 ignore stop */\n    const comment = `# Subtest${stn}\\n`\n    this.parser.write(comment)\n  }\n  // end TAP otput generating methods\n\n  // flow control methods\n\n  /**\n   * Await the end of a Promise before proceeding.\n   * The supplied callback is called with the Waiter object.\n   *\n   * This is internal, used in some plugins when a promise must be awaited\n   * before proceeding. In normal test usage, it's usually best to simply use\n   * an async test function and `await` promises as normal.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  waitOn(\n    promise: Promise<any | void>,\n    cb?: (w: Waiter) => any,\n    expectReject: boolean = false,\n  ): Promise<void> {\n    const w = new Waiter(\n      promise,\n      w => {\n        assert.equal(this.#occupied, w)\n        if (cb) cb(w)\n        this.#occupied = null\n        this.#process()\n      },\n      expectReject,\n    )\n    // if the top of the queue is still the version line, we come\n    // in after that. otherwise, it should be the next thing processed.\n    if (this.queue[0] === VERSION) {\n      this.queue.shift()\n      this.queue.unshift(VERSION, w)\n    } else {\n      this.queue.unshift(w)\n    }\n    this.#process()\n    return w.promise\n  }\n\n  #end(implicit?: typeof IMPLICIT) {\n    if (this.#doingStdinOnly && implicit !== IMPLICIT) {\n      throw new Error('cannot explicitly end while in stdinOnly mode')\n    }\n    this.debug('END %s implicit=%j', this.name, implicit === IMPLICIT)\n    if (this.ended && implicit === IMPLICIT) {\n      this.debug('already ended, ignore implicit end')\n      return\n    }\n\n    // If onbeforeend returns a Promise, then wait for it to finish.\n    const obe = this.onbeforeend\n    if (obe && !this.#pushedBeforeEnd) {\n      this.debug('push obe')\n      this.#pushedBeforeEnd = true\n      if (!queueEmpty(this) || this.#occupied) {\n        this.queue.push(obe)\n        this.#process()\n      } else {\n        const ret = obe()\n        if (isPromise(ret)) {\n          // this will make the next section return this.#process()\n          this.waitOn(ret)\n        }\n      }\n    }\n\n    // beyond here we have to be actually done with things, or else\n    // the semantic checks on counts and such will be off.\n    if (!queueEmpty(this) || this.#occupied) {\n      this.debug(\n        '#end: queue not empty, or occupied',\n        this.#awaitingEnd,\n        this.#occupied,\n        this.queue,\n      )\n      if (!this.#awaitingEnd) {\n        this.#awaitingEnd = implicit === IMPLICIT ? IMPLICIT : true\n      }\n      return this.#process()\n    }\n\n    if (implicit !== IMPLICIT) {\n      if (this.#explicitEnded && this.#awaitingEnd !== true) {\n        this.debug('multi-end')\n        if (!this.#multiEndThrew) {\n          this.#multiEndThrew = true\n          const er = new Error(\n            'test end() method called more than once',\n          )\n          Error.captureStackTrace(er, this.#currentAssert || this.end)\n          er.cause = {\n            test: this.name,\n          }\n          this.threw(er)\n        }\n        return\n      }\n      this.debug('set #explicitEnded=true')\n      // switch from awaiting to processing the explicit end() call.\n      this.#explicitEnded = true\n      this.#awaitingEnd = false\n    }\n\n    if (this.#planEnd === -1 && !this.#doingStdinOnly) {\n      this.debug('END(%s) implicit plan', this.name, this.count)\n      const c =\n        this.count === 0 && !this.parent ? 'no tests found' : ''\n      this.plan(this.count, c, IMPLICIT)\n    } else if (!this.ended && this.#planEnd !== -1) {\n      const count = this.#endingAllSub ? this.count - 1 : this.count\n      if (this.#planEnd > count) {\n        this.fail(`test count(${count}) != plan(${this.#planEnd})`, {\n          found: count,\n          wanted: this.#planEnd,\n          at: this.#planAt,\n          stack: '',\n        })\n      }\n    }\n\n    this.debug('set ended=true')\n    this.ended = true\n    this.queue.push(EOF)\n    this.#process()\n  }\n\n  /**\n   * The full name of the test, starting with the main script name,\n   * and including all parent names.\n   */\n  get fullname(): string {\n    const main = (\n      mainScript('TAP') +\n      ' ' +\n      argv.slice(2).join(' ')\n    ).trim()\n    const n: string[] = [\n      (this.parent ? this.parent.fullname\n      : main === 'TAP' ? 'TAP'\n      : relative(cwd, main).replace(/\\\\/g, '/')\n      ).trim(),\n    ]\n    // tests will generally always have a name\n    /* c8 ignore start */\n    const myName = (this.name || '').trim()\n    /* c8 ignore stop */\n    if (myName) n.push(myName)\n    return n.join(' > ')\n  }\n\n  #process() {\n    if (this.#processing) {\n      return this.debug(' < already processing')\n    }\n    this.debug('\\nPROCESSING(%s)', this.name, this.queue.length)\n    this.#processing = true\n\n    while (!this.#occupied) {\n      const p = this.queue.shift()\n      if (!p) {\n        this.debug('> end of queue')\n        break\n      }\n      if (p instanceof Base) {\n        this.debug('> subtest in queue', p.name)\n        this.#processSubtest(p)\n      } else if (p === EOF) {\n        this.debug(' > EOF', this.name)\n        if (!this.#calledOnEOF) {\n          this.#calledOnEOF = true\n          // I AM BECOME EOF, DESTROYER OF STREAMS\n          this.debug('call onEOF', this.name)\n          const eofRet = this.onEOF()\n          if (isPromise(eofRet)) {\n            this.debug('onEOF is promise')\n            this.waitOn(eofRet, w => {\n              if (w.rejected) {\n                // threw on the parent, since we're EOFing already\n                this.debug('eofRet reject', w.value)\n                this.comment('error thrown in teardown')\n                this.threw(w.value)\n              }\n              this.queue.push(EOF)\n              this.#process()\n            })\n            break\n          }\n        }\n        this.debug('eof end parser', this.name)\n        this.parser.end()\n      } else if (p instanceof TestPoint) {\n        this.debug(' > TESTPOINT')\n        if (p.extra.tapChildBuffer || p.extra.tapChildBuffer === '') {\n          this.#writeSubComment(p)\n          this.parser.write(p.extra.tapChildBuffer)\n        }\n        this.emit('res', p.res)\n        this.parser.write(p.ok + ++this.#n + p.message)\n      } else if (typeof p === 'string') {\n        this.debug(' > STRING')\n        this.parser.write(p)\n      } else if (p instanceof Waiter) {\n        p.ready = true\n        this.#occupied = p\n        p.finish()\n      } else if (typeof p === 'function') {\n        this.debug(' > FUNCTION')\n        const ret = p()\n        if (isPromise(ret)) {\n          this.waitOn(ret)\n        }\n      } else if (Array.isArray(p)) {\n        this.debug(' > METHOD')\n        const m = p.shift() as keyof this\n        const fn = this[m] as (...a: any[]) => any\n        if (typeof fn !== 'function') {\n          this.debug(\n            ' > weird method not found in queue??',\n            m,\n            typeof this[m],\n          )\n          continue\n        }\n        const ret = fn.call(this, ...p)\n        if (isPromise(ret)) {\n          // returned promise\n          ret.then(\n            () => {\n              this.#processing = false\n              this.#process()\n            },\n            (er: unknown) => {\n              this.#processing = false\n              this.threw(er)\n            },\n          )\n          return\n        }\n        /* c8 ignore start */\n      } else {\n        throw new Error('weird thing got in the queue')\n      }\n      /* c8 ignore stop */\n    }\n\n    // waiters are serial\n    const ow = !!this.#occupied && this.#occupied instanceof Waiter\n    while (!this.#noparallel && !ow && this.pool.size < this.jobs) {\n      const p = this.subtests.shift()\n      if (!p) {\n        break\n      }\n\n      if (!p.buffered) {\n        this.#noparallel = true\n        break\n      }\n\n      this.debug('start subtest', p)\n      this.activeSubtests.add(p)\n      this.pool.add(p)\n      this.emit('subtestStart', p)\n      if (this.bailedOut) {\n        this.#onBufferedEnd(p)\n      } else {\n        // ts doesn't know this will always be set at this point\n        /* c8 ignore start */\n        p.options.jobId = this.#getJobId(p.options.childId || 0)\n        /* c8 ignore stop */\n        p.runMain(() => this.#onBufferedEnd(p))\n      }\n    }\n\n    this.debug(\n      'done processing',\n      this.queue,\n      this.#occupied,\n      this.#awaitingEnd,\n    )\n    this.#processing = false\n\n    // just in case any tests ended, and we have sync stuff still\n    // waiting around in the queue to be processed\n    if (!this.#occupied && this.queue.length) {\n      this.#process()\n    } else if (this.idle) {\n      this.debug(\n        'idle after #process',\n        this.#awaitingEnd,\n        this.#occupied,\n      )\n      if (this.#awaitingEnd) {\n        this.debug('awaited end in process', this.#awaitingEnd)\n        this.#end(\n          this.#awaitingEnd === IMPLICIT ? IMPLICIT : undefined,\n        )\n      }\n      // the root tap runner uses this event to know when it is safe to\n      // automatically end.\n      this.emit('idle')\n    }\n  }\n\n  // virtual \"worker\" id, even though it's just a pool\n  #getJobId(childId: number = 0) {\n    let j = childId % this.jobs\n    const start = j\n    while (this.#jobIds.has(j)) {\n      j = (j + 1) % this.jobs\n      // impossible because math\n      /* c8 ignore start */\n      if (j === start) return 0\n      /* c8 ignore stop */\n    }\n    this.#jobIds.add(j)\n    return j\n  }\n\n  /**\n   * True if the test is currently in an idle state\n   */\n  get idle() {\n    return (\n      !this.#processing &&\n      queueEmpty(this) &&\n      !this.pool.size &&\n      !this.subtests.length &&\n      !this.#occupied &&\n      // if we have a plan, don't autoend until the plan is complete.\n      (this.#planEnd === -1 || this.count === this.#planEnd)\n    )\n  }\n\n  #onBufferedEnd<T extends Base>(p: T) {\n    // ignore ends that come in after we've already aborted\n    if (this.ended && this.#endingAll) return\n    this.#jobIds.delete(p.options.jobId || 0)\n    p.results = p.results || new FinalResults(true, p.parser)\n    p.readyToProcess = true\n    const to = p.options.timeout\n    const dur =\n      to && p.passing() ?\n        Number(hrtime.bigint() - p.start) / 1e6\n      : null\n    if (dur && to && dur > to) {\n      p.timeout()\n    } else {\n      p.setTimeout(0)\n    }\n    this.debug(\n      '%s.#onBufferedEnd',\n      this.name,\n      p.name,\n      p.results.bailout,\n    )\n    p.options.tapChildBuffer = p.output || ''\n    p.options.stack = ''\n    if (p.time) p.options.time = p.time\n    if (this.#occupied === p) this.#occupied = null\n    this.pool.delete(p)\n    this.activeSubtests.delete(p)\n    p.deferred?.resolve(p.results)\n    this.emit('subtestEnd', p)\n    this.#process()\n  }\n\n  #onIndentedEnd<T extends Base>(p: T) {\n    // ignore ends that come in after we've already aborted\n    if (this.ended && this.#endingAll) return\n    this.debug('onIndentedEnd', p.name)\n    this.emit('subtestProcess', p)\n    // we'll generally already have a results by now, but just to be sure\n    /* c8 ignore start */\n    p.results = p.results || new FinalResults(true, p.parser)\n    /* c8 ignore stop */\n    this.#noparallel = false\n    const sti = this.subtests.indexOf(p)\n    if (sti !== -1) this.subtests.splice(sti, 1)\n    p.readyToProcess = true\n    p.options.time = p.time\n    const to = p.options.timeout\n    const now = hrtime.bigint()\n    const dur = to && p.passing() ? Number(now - p.start) / 1e6 : null\n    if (dur && to && dur > to) {\n      p.timeout()\n    } else {\n      p.setTimeout(0)\n    }\n    this.debug('#onIndentedEnd %s(%s)', this.name, p.name)\n    this.#occupied = null\n    this.debug('OIE(%s) >shift into queue', this.name, this.queue)\n    p.options.stack = ''\n\n    if (!p.silent || !p.passing()) {\n      if (p.silent) p.options.tapChildBuffer = p.output\n      this.#printResult(p.passing(), p.name, p.options, true)\n    }\n\n    this.debug('OIE(%s) shifted into queue', this.name, this.queue)\n    this.activeSubtests.delete(p)\n    p.deferred?.resolve(p.results)\n    this.emit('subtestEnd', p)\n    this.#process()\n  }\n\n  /**\n   * The main function that starts a test running. Generally no need\n   * to call this directly.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  main(cb: () => void) {\n    if (typeof this.options.timeout === 'number') {\n      this.setTimeout(this.options.timeout)\n    }\n\n    const done = (er?: Error) => {\n      this.donePromise = undefined\n      if (er) this.threw(er)\n\n      if (this.results || this.bailedOut) cb()\n      else\n        this.ondone = () => {\n          super.ondone()\n          cb()\n        }\n    }\n\n    // This bit of overly clever line-noise wraps the call to user-code\n    // in a try-catch. We can't rely on the domain for this yet, because\n    // the 'end' event can trigger a throw after the domain is unhooked,\n    // but before this is no longer the official \"active test\"\n    const ret = (() => {\n      if (!this.cb) return\n      try {\n        return this.cb(this.t || this)\n      } catch (er: any) {\n        if (!er || typeof er !== 'object') {\n          er = { error: er, at: null }\n        }\n        er.tapCaught = 'testFunctionThrow'\n        this.threw(er)\n      }\n    })()\n\n    if (ret && ret.then) {\n      this.donePromise = Object.assign(ret, {\n        tapAbortPromise: done,\n      })\n      ret.then(\n        () => {\n          this.debug(\n            ' > implicit end for promise?',\n            this.#occupied,\n            this.queue,\n            this.#explicitPlan,\n            this.#awaitingEnd,\n          )\n          // the promise has ended\n          // If we had an explicit plan that is now satisfied but was waiting\n          // for the promise to resolve, or if there was no explicit plan, end\n          // the test.\n          this.#promiseEnded = true\n          if (\n            // not already ended\n            !this.ended &&\n            ((!this.#explicitPlan && !this.#awaitingEnd) ||\n              (this.#explicitPlan &&\n                this.#awaitingEnd &&\n                this.count === this.#planEnd)) &&\n            !this.#occupied\n          ) {\n            // this should only be possible if an explicit end()\n            // has been called, because the only other source of an\n            // implicit end is this function right here.\n            this.#end(\n              /* c8 ignore start */\n              this.#awaitingEnd === IMPLICIT ? IMPLICIT : undefined,\n              /* c8 ignore stop */\n            )\n          } else {\n            this.debug('await implicit end')\n            this.#awaitingEnd = IMPLICIT\n          }\n          done()\n        },\n        (er: any) => {\n          if (!er || typeof er !== 'object') {\n            er = { error: er, at: null }\n          }\n          er.tapCaught = 'returnedPromiseRejection'\n          done(er)\n        },\n      )\n    } else {\n      done()\n    }\n\n    this.debug('MAIN post', this.name)\n  }\n\n  #processSubtest<T extends Base>(p: T) {\n    this.debug('processSubtest', p.name)\n    this.debug(' > subtest')\n    this.#occupied = p\n    if (!p.buffered) {\n      this.activeSubtests.add(p)\n      this.emit('subtestStart', p)\n      this.debug(' > subtest indented')\n      p.pipe(this.parser, { end: false })\n      if (!p.silent) this.#writeSubComment(p)\n      this.debug('calling runMain', p.name)\n      p.runMain(() => this.#onIndentedEnd(p))\n    } else if (p.readyToProcess) {\n      this.emit('subtestProcess', p)\n      this.debug(' > subtest buffered, finished')\n      // finished!  do the thing!\n      this.#occupied = null\n      if (!p.passing() || !p.silent) {\n        this.#printResult(p.passing(), p.name, p.options, true)\n      }\n    } else {\n      this.#occupied = p\n      this.debug(' > subtest buffered, unfinished', p)\n      // unfinished buffered test.\n      // nothing to do yet, just leave it there.\n      this.queue.unshift(p)\n    }\n  }\n\n  /**\n   * Parse stdin as the only tap stream (ie, not as a child test)\n   * If used, then no other subtests or assertions are allowed.\n   *\n   * @group Subtest Methods\n   */\n  stdinOnly<T extends BaseOpts>(\n    extra?: T & { tapStream?: Readable | Minipass<string | Buffer> },\n  ) {\n    const stream = (extra?.tapStream ?? process.stdin) as Minipass\n    /* c8 ignore start */\n    if (!stream) {\n      throw new Error('cannot read stdin without stdin stream')\n    }\n    /* c8 ignore stop */\n\n    if (\n      this.queue.length !== 1 ||\n      this.queue[0] !== VERSION ||\n      this.#processing ||\n      this.results ||\n      this.#occupied ||\n      this.pool.size ||\n      this.subtests.length\n    ) {\n      throw new Error('Cannot use stdinOnly on a test in progress')\n    }\n\n    this.#doingStdinOnly = true\n    this.queue.length = 0\n    this.parser.on('child', p => {\n      // pretend to be a rooted parser, so it gets counts.\n      p.root = p\n      const t = new Base({\n        name: p.name,\n        parent: this,\n        parser: p,\n        bail: p.bail,\n        strict: p.strict,\n        omitVersion: p.omitVersion,\n        preserveWhitespace: p.preserveWhitespace,\n        childId: this.#nextChildId++,\n      })\n      this.emit('subtestAdd', t)\n      this.activeSubtests.add(t)\n      this.emit('subtestStart', t)\n      this.emit('subtestProcess', t)\n      p.on('complete', () => {\n        t.time = p.time\n        this.activeSubtests.delete(t)\n        this.emit('subtestEnd', t)\n      })\n    })\n    stream.pipe(this.parser)\n    stream.resume()\n  }\n\n  /**\n   * Mount a subtest, using this Test object as a harness.\n   * Exposed so that it can be used by some builtin plugins, but perhaps\n   * the least convenient way imaginable to create subtests. Just use\n   * `t.test()` to do that, it's much easier.\n   *\n   * @group Subtest Methods\n   *\n   * @internal\n   */\n  sub<T extends Base, O extends BaseOpts>(\n    Class: { new (options: O): T },\n    extra: O | TestBaseOpts = {},\n    caller: (...a: any[]) => unknown = this.sub,\n  ): PromiseWithSubtest<T> {\n    if (this.bailedOut) {\n      return Object.assign(Promise.resolve(null), {\n        subtest: null,\n      })\n    }\n\n    if (this.results || this.ended) {\n      const msg =\n        this.#promiseEnded ?\n          'cannot create subtest after parent promise resolves'\n        : this.#explicitEnded ? 'subtest after parent test end()'\n        : this.#explicitPlan ? 'test count exceeds plan'\n        : /* c8 ignore start */\n          'cannot create subtest after parent test ends'\n      /* c8 ignore stop */\n      const er = new Error(msg)\n      Error.captureStackTrace(er, caller)\n      this.threw(er)\n      return Object.assign(Promise.resolve(null), {\n        subtest: null,\n      })\n    }\n\n    extra.childId = this.#nextChildId++\n    if (this.shouldSkipChild(extra)) {\n      this.currentAssert = this.sub\n      this.pass(extra.name || '', extra)\n      return Object.assign(Promise.resolve(null), {\n        subtest: null,\n      })\n    }\n\n    extra.indent = '    '\n    if (extra.buffered === undefined && !extra.silent) {\n      extra.buffered = this.jobs > 1\n    }\n\n    extra.parent = this\n    if (!extra.at && extra.at !== null) {\n      const st = stack.capture(80, caller)\n      extra.at = st[0]\n      extra.stack = st.map(c => String(c)).join('\\n')\n    }\n\n    this.#inheritFlags(extra)\n\n    const t = new Class(extra as O)\n\n    this.queue.push(t)\n    this.subtests.push(t)\n    this.emit('subtestAdd', t)\n    // this would make its way here eventually anyway, but the\n    // test bailing out might be waiting for its turn in the pool\n    // to be processed, and bailout should happen ASAP.\n    t.on('bailout', reason => this.bailout(reason))\n\n    const d = new Deferred<FinalResults>()\n    t.deferred = d\n    this.#process()\n    return Object.assign(d.promise, { subtest: t })\n  }\n\n  /**\n   * Method called when an unrecoverable error is encountered in a test.\n   *\n   * Typically, in tests you would not call this, you'd just actually throw\n   * an error.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  threw(\n    er: any,\n    extra?: Extra,\n    proxy: boolean = false,\n  ): Extra | void | undefined {\n    this.debug('TestBase.threw', this.name, er.message)\n    // this can happen if a beforeEach throws.  capture the error here\n    // and raise it once we've started the test officially.\n    if (this.parent && !this.started) {\n      this.cb = () => {\n        this.threw(er)\n        this.end()\n      }\n      return\n    }\n\n    // suppress the callsite for non-error throws, since\n    // it'll always just be useless noise pointing back here.\n    if (typeof er === 'string') {\n      er = { message: er, at: null }\n    }\n\n    if (this.name && !proxy) {\n      er.test = this.name\n    }\n    if (!proxy) {\n      extra = extraFromError(er, extra)\n    }\n    this.debug('T.t call Base.threw', this.name, er, extra)\n    const ended =\n      !!this.results ||\n      // should be impossible, when we hit the plan end, we end\n      /* c8 ignore start */\n      (this.#explicitPlan && this.count === this.#planEnd)\n    /* c8 ignore stop */\n    this.parser.ok = false\n    const threwInfo = super.threw(er, extra, proxy, ended)\n\n    // Handle the failure here, but only if we (a) don't have\n    // results yet (indicating an end) and (b) are not currently\n    // at the plan end (which would mean that any failure is\n    // ignored to prevent infinite regress in \"plan exceeded\"\n    // failures)\n    if (!ended && threwInfo) {\n      const msg = threwInfo.message as string\n      extra ??= { at: null }\n      if (this.parent && extra.test === this.name) {\n        // remove extraneous indicator if it's already nested\n        // in a TAP subtest\n        delete extra.test\n      }\n      if (extra.error === msg) {\n        delete extra.error\n      }\n      if (!extra.stack && er.stack && typeof er.stack === 'string') {\n        // trim off the first line if it looks like the standard\n        // error `Name: message` line.\n        /* c8 ignore start */\n        const f = `${er.name || 'Error'}: ${er.message}\\n`\n        const st =\n          er.stack.startsWith(f) ?\n            er.stack.substring(f.length)\n          : er.stack\n        /* c8 ignore stop */\n        const p = stack.parseStack(st)\n        extra.at = p[0] || null\n        extra.stack = p.map(c => String(c) + '\\n').join('')\n      }\n      if (!extra.at && !extra.stack) extra.at = null\n      this.fail(msg, extra)\n      if (this.ended || this.#awaitingEnd) {\n        this.ended = false\n        this.#awaitingEnd = false\n        this.end(IMPLICIT)\n      }\n    }\n    if (this.#occupied && this.#occupied instanceof Waiter) {\n      this.#occupied.abort(\n        Object.assign(\n          new Error('error thrown while awaiting Promise'),\n          { thrown: er },\n        ),\n      )\n      this.#occupied = null\n    }\n    if (!proxy) {\n      this.#end(IMPLICIT)\n      this.#processing = false\n    }\n\n    this.#process()\n    /* c8 ignore start */\n    this.donePromise?.tapAbortPromise?.()\n    /* c8 ignore stop */\n  }\n\n  /**\n   * Method called when the parser encounters a bail out\n   *\n   * To listen to bailout events, listen to the\n   * {@link @tapjs/core!base.TapBaseEvents#bailout} event:\n   *\n   * ```ts\n   * t.on('bailout', message => {\n   *   // test bailed out!\n   * })\n   * ```\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  onbail(message?: string) {\n    super.onbail(message)\n    this.#end(IMPLICIT)\n    if (!this.parent) {\n      this.endAll()\n    } else {\n      throw 'bailout'\n    }\n  }\n\n  /**\n   * Called when a test times out or bails out, or the process ends,\n   * marking all currently active or queued subtests as incomplete.\n   *\n   * No need to ever call this directly, exposed so that it can be extended by\n   * {@link @tapjs/core!spawn.Spawn} and {@link @tapjs/core!worker.Worker},\n   * which have special behaviors that are required when a process hangs\n   * indefinitely.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  endAll(sub: boolean = false) {\n    if (this.bailedOut) return\n    this.#endingAll = true\n    this.#endingAllSub = sub\n\n    // in the case of the root TAP test object, we might sometimes\n    // call endAll on a bailing-out test, as the process is ending\n    // In that case, we WILL have a this.occupied and a full queue\n    // These cases are very rare to encounter in other Test objs tho\n    this.#processing = true\n    if (this.#occupied) {\n      const p = this.#occupied\n\n      if (p instanceof Waiter) p.abort(new Error('test unfinished'))\n      else if (typeof (p as TestBase).endAll === 'function') {\n        // first try to end explicitly, then endAll if that didn't work\n        const pt = p as TestBase\n        pt.endAll(true)\n      } else p.parser.abort('test unfinished')\n      this.#occupied = null\n    } else if (sub) {\n      this.#process()\n      if (\n        queueEmpty(this) &&\n        (this.#planEnd === -1 || this.count < this.#planEnd)\n      ) {\n        const options = Object.assign({}, this.options)\n        options.test = this.name\n        this.fail('test unfinished', options)\n      }\n    }\n\n    this.donePromise?.tapAbortPromise?.()\n\n    for (let i = 0; i < this.queue.length; i++) {\n      const p = this.queue[i]\n      if (p instanceof Base && !p.readyToProcess) {\n        const msg = `child test left in queue: ${p.name}`\n        delete p.options.skip\n        delete p.options.todo\n        this.queue[i] = new TestPoint(false, msg, p.options)\n        this.count++\n      }\n    }\n\n    this.#processing = false\n    this.#process()\n    this.end(IMPLICIT)\n    this.#process()\n  }\n\n  /**\n   * Return true if the child test represented by the options object\n   * should be skipped.  Extended by the `@tapjs/filter` plugin.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  shouldSkipChild<O extends BaseOpts>(\n    extra: O | TestBaseOpts | BaseOpts,\n  ): boolean {\n    return !!(extra.skip || extra.todo)\n  }\n}\n"]}